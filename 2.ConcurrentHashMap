q:那如何在多线程的情况下保证线程安全呢
s：这个需要使用到concurrenthashmap。这个在jdk1.8和1.7之间也是有差别的。
体现在1.7的时候是segment锁，就是锁一个段落。它把一个大数组切成了 16 个小段，相当于是锁其中的1个，理论上可以提高16倍的效率
但是1JDK 1.8 觉得分段锁还是不够细！因为它毕竟还是锁了一整段（可能包含几千个 HashEntry）。所以1.8使用了一个CAS 也就是compare and swap （比较和交换）
加上synchronized 关键字。只锁住这一个链表的头节点。只要不冲突，那就可以插入。

CAS ： 无锁操作
(Compare And Swap) 算法：

          尝试： “我看这里是空的，我试试能不能直接把数据放进去？”

          结果： 如果放进去的瞬间没有别人抢，那就成功了；如果被人抢先了，就重试。

          优势： CAS 是操作系统层面的指令，速度极快，没有“加锁/解锁”的重型开销。

2. 如果车位有人（发生冲突）：synchronized
          如果计算出的位置已经有数据了（链表或红黑树），说明发生了冲突。 这时候，JDK 1.8 会利用 synchronized 关键字，只锁住这一个链表的头节点。

          比喻： 我只锁这一个车位，旁边车位随便停。

          粒度： 这是最小粒度的锁（Node 级别）。


     满分回答：：：

    “ConcurrentHashMap 在 JDK 1.7 和 1.8 的实现差异很大：

    JDK 1.7 采用的是 分段锁 (Segment) 机制。它把整个 Map 分成 16 个 Segment，每个 Segment 是一把独立的 ReentrantLock。只有操作同一个 Segment 时才会竞争，并发度最高是 16。

    JDK 1.8 完全抛弃了 Segment。它采用了 CAS + synchronized 的机制来保证线程安全。

    如果插入的位置是空的，直接利用 CAS 尝试插入，不需要加锁。

    如果位置有数据（发生 Hash 冲突），则利用 synchronized 锁住当前链表的头节点。

    核心优势： 1.8 的锁粒度从‘段’缩小到了‘节点’，并发控制更加精细，性能更高。”