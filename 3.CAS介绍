q：既然你提到了CAS，那你讲一下这个东西
s：cas是并发编程的基石，全称是compare and swap  比较并交换。核心思想是乐观锁。
就是，我觉得没人和我抢，所以我直接去改，改的时候看下是不是一致的，是的话那就改了，不是的话那就不改了，或者重试。
里面最重要的三个参数：
V 原来的值
A  期待的值
B 改变后的值

CAS的工作原理是只有当V=A的时候，才把V改成B。。
但是有一个致命的问题是，ABA问题，，就是把A改成B又被改回来成A了。
在简单的数值修改（比如 AtomicInteger 计数）中，ABA 其实无所谓，反正最终结果对了就行。

但在堆栈（Stack）或链表操作中，ABA 是致命的。 如果一个节点对象 A 被移出队列，回收了，然后又被重用重新加回队列（内存地址还是 A）。其他线程可能还在引用旧的 A，导致链表逻辑完全断裂，出现数据丢失。

怎么解决就是加个版本号。。 刚开始数字是1 版本号是1  后面改成了2 版本号是2  后面改回来是1 版本号是3   这个时候其实就有问题了，说明被改过了。

java中解决这个办法是使用AtomicStampedReference类，这个类里面内置了一个pair对象，存储了当前值和当前版本号

核心思想就是：不仅要对比值，还要对比版本号。只有都一致了才能修改




