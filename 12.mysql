学完自己回忆版：
1.mysql采用的是B+树来存储数据。
三层结构。非叶子节点和叶子节点
叶子节点村的是聚簇索引，也就是id索引，这里存了当前这一条的所有数据
非叶子节点存的是非聚簇索引。有自己创建的索引

回表的意思是：比如我创建name索引，那我查到这个name的时候，如果是select *  ,因为我要去查询所有的数据，那就先拿到name索引上的id值
，再回表查询聚簇索引，因为id 上有所有数据。。这就回表   如果我查索引，只返回索引，那就全覆盖了，就不需要回表查询了，效率就更快
mysql
隔离级别：默认可重复读。

事务：begin： commit.

锁：for update。

日志  redo log  undo log   binlog

总：MySQL 选 B+ 树做索引
非叶子节点（上面的蓝块）： 只存索引值（Key）和指针。它们不存真实数据，只负责指路。

叶子节点（最下面的一排）： 存真实数据（Data）或者主键 ID。

双向链表： 所有叶子节点通过指针手拉手连在一起（方便范围查询，比如 > 18）。

explain

1000 万数据，分页查询慢。
方案一：利用“覆盖索引” + “延迟关联” (Late Row Lookup)

总结（面试满分话术）
如果面试官问：“千万级数据，范围查询加了索引还是很慢，为什么？”

“这通常是因为回表成本过高或者索引失效导致的。

如果查询范围过大（超过 30%），MySQL 优化器会认为全表扫描比随机 IO 的回表更划算，从而放弃索引。

如果配合了 LIMIT 但还是很慢，通常是因为 ORDER BY 的字段和 WHERE 的字段不一致，导致无法利用索引的有序性，触发了 Using filesort。

解决方案通常是使用延迟关联 (Late Row Lookup)。 先通过覆盖索引查询出目标主键 ID（避免回表），再通过 ID 关联主表获取完整数据。这样可以将几百万次的回表操作降低为页面大小的次数。”





