1. 虚拟机栈 (Java Stack) —— 你的“私有工位”
特点： 线程私有（每个线程都有自己的栈）。

存什么： 局部变量（方法里定义的 int a = 1）、方法调用链。

生命周期： 极其短！ 方法一开始执行，入栈；方法执行完，马上出栈（清空）。所以栈里没有垃圾回收（GC）这一说，用完就扔。

常见报错： StackOverflowError（通常是因为死递归，工位堆满了）。

2. 堆 (Heap) —— 饭店的“大堂/仓库”
特点： 所有线程共享（谁都能来拿）。这是 JVM 内存最大的一块，也是 GC 主要工作的地方。

存什么： 对象实例（new 出来的东西全在这里）。

生命周期： 只要对象还有人用，就一直存着；没人用了，等 GC 来收盘子。

常见报错： OutOfMemoryError: Java heap space（对象太多，仓库爆了）。

3. 方法区 / 元空间 (Metaspace) —— 饭店的“菜单墙”
特点： 线程共享。

存什么： 类的信息（Class）、常量、静态变量（Static）。

变化： JDK 1.7 叫“永久代 (PermGen)”，JDK 1.8 改名叫“元空间 (Metaspace)”，并且直接使用了本地内存（不再受 JVM 堆大小限制，不容易爆）。

3. 堆内存的精细结构：GC 的战场
面试官接着会问：“堆里面又是怎么分区的？” 这是为了引出 垃圾回收机制。

Java 堆并不是一整块大平地，而是分成了**“新生代”和“老年代”**。

新生代 (Young Generation) —— 1/3 的空间

Eden 区（伊甸园）： 刚 new 出来的对象都在这。大部分对象（比如 HTTP 请求里的临时对象）都是“朝生夕死”的，很快就会死掉。

Survivor 区（幸存者区 S0/S1）： 经过一次 GC 还没死的，会被挪到这里。

老年代 (Old Generation) —— 2/3 的空间

存活了很久的对象（经历了 15 次 GC 还没死），或者特大的对象，会进入老年代。这里通常存的是缓存、Spring Bean、数据库连接池这种“老不死”的对象。


4. 模拟面试：场景题
面试官： “我的线上服务经常出现 Full GC（老年代GC），导致系统卡顿，你觉得可能是什么原因？”

你的分析思路（满分答案）：

“Full GC 频繁，说明老年代（Old Gen）满了。 老年代满了，通常有几种情况：

内存泄漏： 有代码没写好（比如刚才说的 ThreadLocal 没 remove，或者 static 集合一直加数据），导致大量无用对象无法回收，一直占着老年代。

大对象直接进老年代： 系统里是不是在频繁加载很大的 Excel 或图片？大对象不经过新生代，直接进老年代，把老年代撑爆了。

代码逻辑问题（过早晋升）： 新生代太小了，导致很多本来应该在新生代死掉的短命对象，因为没地方放，被迫提前进入了老年代。”