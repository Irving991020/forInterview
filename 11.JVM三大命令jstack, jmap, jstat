这三个命令（jstack, jmap, jstat）是 JDK 自带的**“JVM 救火三剑客”**。面试官问这类问题，通常场景非常具体，
比如：“生产环境 CPU 突然飙升到 100%，你怎么排查？” 或者 “内存溢出了，你怎么找到是哪个对象在搞鬼？”作为 5 年经验，你不能只回答“用 jstack”，
你必须把**排查步骤（SOP）**像报菜名一样说出来。我们分场景来实战。场景一：CPU 飙高 100% (必考题)核心工具： jstack (查看线程堆栈)
原理： CPU 高通常意味着有线程在死循环，或者在进行极其复杂的计算。我们要把这个“坏线程”抓出来，看看它在运行哪行代码。排查步骤（面试满分话术）：
定位进程：使用 top 命令，看到 Java 进程的 CPU 占用率很高。记下它的进程 ID (比如 PID = 1001)。定位线程 (关键一步)：Java 是多线程的。
我们要知道是进程里的哪个线程在耗 CPU。输入命令：top -Hp 1001-H: 显示线程模式。-p: 指定进程。你会看到一个列表，找到 CPU 最高的那个线程 ID (
比如 TID = 1050)。进制转换 (装逼时刻)：jstack 输出的日志里，线程 ID 是16进制的，而刚才 top 看到的是10进制的。我们需要把 1050 转成 16
进制。命令：printf "%x\n" 1050 -> 结果是 41a。抓取堆栈 (jstack)：使用 jstack 抓取当时的线程快照，并搜索这个 16进制的 ID。命令：js
tack 1001 | grep -A 20 0x41a1001: 进程 ID。0x41a: 刚才转出来的 16进制线程 ID。-A 20: 打印匹配行后面的 20 行日志。分析原因：你会
直接看到代码行号！如果状态是 RUNNABLE 且指向你的业务代码（比如 UserService.java:50），那这行代码大概率在死循环。如果全是 BLOCKED，
说明发生了死锁（Deadlock）。场景二：内存泄露 / OOM (OutOfMemory)核心工具： jmap (查看内存映射)原理： 堆内存满了，我们要看看堆里到
底存了什么对象？是几十万个 User 对象？还是巨大的 byte[] 数组？排查步骤：方法 A：快速查看（线上轻量级）如果你不想把服务搞挂，只是想
粗略看看谁占得最多。命令：Bash# -histo:live 只统计活着的对象
jmap -histo:live 1001 | head -n 20

输出结果：你会看到一个排行榜。第一名：[C (这是 char[]，通常代表 String 内容)。第二名：com.example.User (如果有几十万个 User，说
明 User 没回收)。方法 B：深度尸检（Dump 文件）如果方法 A 看不出来，或者已经 OOM 挂了，我们需要把整个内存**Dump（转储）**下来分析
。命令：Bash# 把内存快照保存成 heap.bin 文件
jmap -dump:format=b,file=heap.bin 1001
⚠️ 5年经验避坑点：“线上服务能不能随便执行 jmap -dump？”答：绝对不能！因为 Dump 10GB 的内存需要时间，这个过程中 JVM 会暂停
服务 (STW)。如果你在线上高峰期执行这个命令，服务会卡死几十秒，导致大量请求超时。正确做法： 摘除流量（把这台机器从负载均衡里拿下
来），再 Dump；或者配置 -XX:+HeapDumpOnOutOfMemoryError 让它死的时候自动 Dump。后续分析：拿到 heap.bin 后，你看不懂二进制。
要下载到本地，用 JVisualVM (JDK自带) 或 MAT (Eclipse Memory Analyzer) 打开分析。场景三：GC 频繁 / 系统卡顿核心工具： jstat
(查看 GC 统计)原理： 有时候系统没挂，但就是慢。可能是 GC 太频繁了。我们需要实时监控 GC 的频率。命令：Bash# 每隔 1000毫秒(1秒
) 打印一次 GC 情况，打印 10 次
jstat -gc 1001 1000 10
输出解读 (需要背几个缩写)：列名含义5年经验分析法S0C / S1CSurvivor 区容量-S0U / S1USurvivor 区用量-EC / EUEden 区容量/用量
新生代OC / OUOld (老年代) 容量/用量重点看 OU！ 如果 OU 一直涨不掉，说明有内存泄露风险。YGCYoung GC 次数频繁没关系（1秒1次
都正常）。FGCFull GC 次数致命指标！ 正常系统几天才一次。如果你发现 FGC 每几秒就跳一下，说明系统已经崩了。FGCTFull GC 总耗时
如果耗时很长，系统就会卡顿。总结：面试怎么说？如果面试官问：“你平时怎么做 JVM 调优或排查？”你的回答（套路）：“一般分为三种
情况：CPU 飙高： 我会用 top -Hp 找到最耗 CPU 的线程 ID，转成 16 进制，然后用 jstack 抓取堆栈，精准定位到是哪一行代码在死
循环或计算复杂。内存问题： 如果是 OOM，我会分析 -XX:+HeapDumpOnOutOfMemoryError 自动生成的 Dump 文件（用 MAT 工具），
看是哪个大对象占用了堆。如果是日常排查，我会用 jmap -histo:live 快速看下对象直方图。卡顿/GC问题： 我会用 jstat -gc 实时
监控。如果发现 FGC（Full GC） 次数频繁增加，或者老年代 OU 居高不下，我就知道需要优化内存结构或调整 GC 参数了。”👉 下
一步：最后一公里至此，JVM 的内存结构、GC 算法、排查工具你都拿下了。Java 后端开发的两大基石：Java 基础（并发） 和 JVM
 你已经通关。接下来通常面试会转向：MySQL 数据库（索引、锁、慢 SQL 优化）。Redis 缓存（穿透、雪崩、一致性）。Sprin
 g 框架（Bean 生命周期、AOP 原理）。你想先攻克哪一个？（建议先看 MySQL，因为“索引优化”是 100% 必问的）。