q：介绍下你了解的HashMap
s:hashmap的组成在jdk1.7和1.8是不一样的。在1.7里是数组加链表结构。在1.8里升级成了数组加链表加红黑树的组成结构
原理是，在hashmap里put值的时候，他是会算出每一个值的hashcode，但是不直接使用这个hashcode，是用这个hashcode
与它本身向右移16位数之后的一个数去做与或运算。最后用这个值去做取模运算。得到他的数组下标。然后就放在哪个数组下面
如果下标相同，则往后放在链表中。这个插入链表1.7中使用的方法是头插法，1.8中使用的是尾插法。是因为头插法在多线程扩容的时候
会容易导致链表成为死循环，环形链表，尾插法可以解决这个问题。 然后扩容是这样的，扩容他本身是有一个0.75的一个负载因子。
初始容量是16，如果插入了12个数之后，百分之百会发生扩容，不管是不是在不同的数组下面。因为size就是12，达到了16X0.75的一个阈值。
扩容机制是这样的，1.7和1.8还是有所不同。
1.7中 所有数据都要重新计算 Hash，重新取模，重新分配位置。效率很低，且多线程下容易死循环
JDK 1.8（优化）： 不需要重新计算 Hash！

因为它每次扩容都是翻倍（比如 16 -> 32），数据要么留在原地，要么**移动到“原位置 + 旧数组长度”**的位置。

优点： 省去了重新计算 Hash 的开销，效率极高。

最终：
关于 HashMap：

底层结构： 1.7 是数组+链表；1.8 变成了数组+链表+红黑树。

Hash 计算： 为了防止冲突，1.8 会先拿 Key 的 HashCode，把高 16 位和低 16 位做异或混合。

寻址逻辑： 然后用这个混合后的值，和 数组长度-1 做按位与运算，算出下标。

冲突处理： 如果位置有人了，就用链表挂在后面。1.7 用头插法（在扩容的时候容易死循环），1.8 改成了尾插法。

树化机制： 当链表长度 > 8 且数组长度 >= 64 时，链表转为红黑树，优化查询效率。

扩容机制： 当元素数量超过 容量 * 0.75 时，数组翻倍。1.8 在扩容时做了优化，数据要么在原地，要么平移，不需要重新计算 Hash。”

优先扩容