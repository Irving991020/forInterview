GC（垃圾回收）是 Java 面试中含金量最高的部分。 面试官问 GC，其实是在问：“你的系统卡顿了（STW），你知道是哪款回收器在捣乱吗？你知道怎么换成更平滑的回收器吗？”

作为 5 年经验，我们不能只背概念，要懂演进过程：从“一刀切”到“分块治理”。

1. 核心痛点：Stop The World (STW)
在讲具体回收器之前，你必须懂这个词。 不管什么 GC 算法，在某些阶段，都必须暂停所有用户线程（你正在下单、正在支付，全部卡住不动），专心扫垃圾。

比喻： 阿姨打扫卫生时，大喊一声：“都在座位上别动（STW）！我要拖地了，动了我就拖不干净了！”

目标： 所有 GC 技术的进化，都是为了减少 STW 的时间。

2. 回收算法（方法论）
针对新生代和老年代存活对象数量不一样，GC 采用了不同的算法：

复制算法 (Copying) —— 新生代专用

逻辑： 内存一分为二。把活着的对象复制到另一边，剩下的直接清空。

为什么新生代用？ 因为新生代 90% 的对象都是“朝生夕死”的，活下来的很少，所以复制成本极低，效率极高。

标记-清除 / 标记-整理 —— 老年代专用

逻辑： 活着的对象太多了，复制不动。只能把垃圾标记出来，原地干掉。

缺点： 容易产生内存碎片（像 Swiss Cheese 奶酪一样，全是洞，放不下大对象）。

3. 两大主角：CMS vs G1 (面试必考)
对于 5 年经验，Serial 和 Parallel 这种早古回收器简单了解即可。面试的重头戏在 CMS 和 G1。

A. CMS (Concurrent Mark Sweep) —— JDK 8 之前的“低延迟之王”
它的特点是**“并发”。除了开头和结尾，中间的大部分标记过程，GC 线程是和你的业务线程一起跑的**（一边扔垃圾，一边扫垃圾）。

四个步骤（背下来）：

初始标记 (STW)： 暂停一下，只记录GC Roots 直接引用的对象（速度极快）。

并发标记： 恢复运行，顺着刚才的记录往下找。（最耗时，但不需要暂停业务）。

重新标记 (STW)： 再暂停一下，修正刚才并发期间变动过的数据。

并发清除： 恢复运行，清理垃圾。

致命缺点（为什么被淘汰）：

内存碎片： 它是“清除”算法，不进行整理。老年代会有很多空隙，导致大对象进不去，触发 Full GC。

B. G1 (Garbage First) —— JDK 9 默认，当下的主流
G1 是一款颠覆性的收集器。它不再把堆物理上分成一块大的新生代、一块大的老年代，而是把内存切成了几千个小格子（Region）。

核心优势（5年经验必答）：

化整为零： 就像切蛋糕一样。每个格子既可以是 Eden，也可以是 Old。

可预测停顿 (Predictable Pause)： 这是 G1 最牛的地方！

你可以设置一个参数：-XX:MaxGCPauseMillis=200。

G1 会算：“如果要全部回收，需要 500ms，不行，老板只给 200ms。那我这次只回收垃圾最多的那几个格子吧！”

这就是 Garbage First（垃圾优先）名字的由来——优先回收价值最大的 Region。

无碎片： 它是基于“复制”算法的（把这个格子的活对象，复制到那个格子），天然整理了内存。

4. 怎么选？（面试实战话术）
面试官： “你们线上用的什么 GC？为什么选它？”

满分回答范本：

“我们目前的生产环境（JDK 8）主要使用的是 G1 收集器。

早期我们用过 CMS，但发现它有两个痛点：

它基于标记-清除算法，运行久了老年代碎片化严重，频繁触发 Full GC。

停顿时间不可控，有时候业务高峰期一卡就是 1-2 秒。

后来我们迁移到了 G1。G1 把内存划分成多个 Region，最大的优势是可以设置期望的停顿时间 (MaxGCPauseMillis)。 它能根据我们设定的 200ms 阈值，智能选择回收收益最高的 Region，既保证了吞吐量，又避免了长时间的卡顿 (STW)。这对于我们这种对响应时间敏感的电商业务非常重要。”

5. 补充一个“炫技”点：ZGC
如果面试官问：“你了解最新的技术吗？” 你可以提一嘴 ZGC（JDK 11/17+）：

“我还了解过 ZGC，它是以后的趋势。它通过染色指针和读屏障技术，做到了几乎全部并发。不管堆内存多大（哪怕 1TB），它的 STW 时间都能控制在 10ms 以内。不过我们目前业务规模 G1 够用了，还没升级到 ZGC。”

总结
新生代： 复制算法（快）。

老年代： 标记整理（稳）。

CMS： 并发收集，但有碎片（过时）。

G1： 格子化划分，可预测停顿，无碎片（主流）。